searchState.loadedDescShard("mithril_stm", 0, "Mithril-stm CI workflow crates.io Discord\nThe aggregated signature is invalid\nError types for aggregation.\nBatch verification of STM signatures failed\nBatch verification of STM aggregate signatures failed\n<code>CoreVerifier</code> check failed\nErrors which can be output by <code>CoreVerifier</code>.\nMSP.Eval was computed incorrectly\nThere is an index out of bounds\nThere is a duplicate index\nOne of the aggregated signatures is invalid\nThe IVK is invalid after aggregating the keys\nThe supplied key is not valid\nThis key has already been registered by a participant\nThe lottery was actually lost for the signature\nNo quorum was found\nNot enough signatures were collected, got this many …\nInvalid merkle batch path\nErrors which can be outputted by key registration.\nThis error occurs when the the serialization of the raw …\nThis error occurs when the the serialization of the raw …\nSerialization error\nA party submitted an invalid signature\nErrors which can be output by Mithril aggregate …\nErrors which can be output by Mithril single signature …\nUnregisteredInitializer error\nThis error happens when we try to convert a u64 to a usize …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nKey registration functionality.\nBase multi-signature scheme, used as a primitive for STM. …\nTop-level API for Mithril Stake-based Threshold …\nStructure generated out of a closed registration …\nStruct that collects public keys and stakes of parties. …\nStores a registered party with its public key and the …\nFinalize the key registration. This function disables …\nReturns the argument unchanged.\nReturns the argument unchanged.\nInitialise an empty <code>KeyReg</code>. todo: remove this init function\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nUnique public key out of the key registration instance.\nOrdered list of registered parties.\nVerify and register a public key and stake for a …\nTotal stake of the registered parties.\nMultiSig proof of possession, which contains two elements …\nMultiSig signature, which is a wrapper over the <code>BlstSig</code> …\nMultiSig secret key, which is a wrapper over the BlstSk …\nMultiSig verification key, which is a wrapper over the …\nMultiSig public key, contains the verification key and the …\nAggregate a slice of verification keys and Signatures by …\nBatch verify several sets of signatures with their …\nif <code>e(k1,g2) = e(H_G1(&quot;PoP&quot; || mvk),mvk)</code> and …\nDense mapping function indexed by the index to be …\nReturns the argument unchanged.\nConvert a secret key into an <code>MspMvk</code>. This is performed by …\nReturns the argument unchanged.\nConvert a secret key into an <code>MspPoP</code>. This is performed by …\nReturns the argument unchanged.\nConvert a secret key into a <code>VerificationKeyPoP</code> by simply …\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert a string of bytes into a <code>SigningKey</code>.\nConvert a compressed byte string into a <code>VerificationKey</code>.\nDeserialize a byte string to a <code>PublicKeyPoP</code>.\nDeserialize a byte string to a <code>PublicKeyPoP</code>.\nConvert a string of bytes into a <code>MspSig</code>.\nGenerate a secret key\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nProof of Possession.\nSign a message with the given secret key\nConvert the secret key into byte string.\nConvert an <code>VerificationKey</code> to its compressed byte …\nConvert to a 96 byte string.\nConvert to a 144 byte string.\nConvert an <code>Signature</code> to its compressed byte representation.\nVerify a signature against a verification key.\nVerify a set of signatures with their corresponding …\nThe verification key.\nFull node verifier including the list of eligible signers …\nQuorum index for signatures. An aggregate signature (…\nThe quantity of stake held by a party, represented as a <code>u64</code>…\n<code>StmMultiSig</code> uses the “concatenation” proving system …\nStm aggregate key (batch compatible), which contains the …\n<code>StmClerk</code> can verify and aggregate <code>StmSig</code>s and verify …\nInitializer for <code>StmSigner</code>. This is the data that is used …\nUsed to set protocol parameters.\nSignature created by a single party who has won the …\nSignature with its registered party.\nParticipant in the protocol can sign messages.\nWrapper of the MultiSignature Verification key\nWrapper of the MultiSignature Verification key with proof …\nAggregate a set of signatures for their corresponding …\nThe list of unique merkle tree nodes that covers path for …\nBatch verify a set of signatures, with different messages …\nCollects and returns the winning indices.\nCompare two <code>StmSig</code> by their signers’ merkle tree indexes.\nCompute the <code>StmAggrVerificationKey</code> related to the used …\nA core signature generated without closed registration. …\nGiven a slice of <code>sig_reg_list</code>, this function returns a new …\nList of registered parties.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nExtract the <code>StmParameters</code> from a byte slice.\nConvert a slice of bytes to an <code>StmInitializer</code>\nExtract a batch compatible <code>StmSig</code> from a byte slice.\nExtract a <code>StmSigRegParty</code> from a byte slice.\nExtract a <code>StmAggrSig</code> from a byte slice.\nCreate a new <code>Clerk</code> from a closed registration instance.\nCreate a Clerk from a signer.\nGet the (VK, stake) of a party given its index.\nExtract stake from the signer.\nThe index(es) for which the signature is valid\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nQuorum parameter.\nSecurity parameter, upper bound on indices.\nCreates a new core signer that does not include closed …\nBuild the <code>avk</code> for the given list of parties.\nCurrent protocol instantiation parameters.\n<code>f</code> in phi(w) = 1 - (1 - f)^w, where w is the stake of a …\nProof of Possession.\nRegistered party\nSetup a core verifier for given list of signers. * Collect …\nBuilds an <code>StmInitializer</code> that is ready to register with …\nStm signature\nThe signature from the underlying MSP scheme.\nThis function produces a signature following the …\nMerkle tree index of the signer.\nThis participant’s stake.\nConvert to bytes\nConvert to bytes\nConvert an <code>StmSig</code> into bytes\nConvert StmSigRegParty to bytes\nConvert multi signature to bytes\nTotal stake of registered parties.\nExtract the verification key.\nExtract the verification key.\nCore verification\nVerify an stm signature by checking that the lottery was …\nVerify aggregate signature, by checking that\nVerify a core signature by checking that the lottery was …\nThe verification key.")